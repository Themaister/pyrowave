#version 450
// Copyright (c) 2025 Hans-Kristian Arntzen
// SPDX-License-Identifier: MIT
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_shuffle_relative : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

#include "dwt_quant_scale.h"
#include "constants.h"

layout(local_size_x_id = 0) in;

layout(set = 0, binding = 0) uniform sampler2DArray uTexture;

struct QuantStats
{
    float16_t square_error;
    uint16_t payload_cost;
};

struct BlockMeta
{
    uint code_word;
    uint offset;
};

// Fit into 64 bytes.
struct BlockStats
{
    uint num_planes;
    QuantStats errors[15];
};

layout(set = 0, binding = 1) writeonly buffer SSBOMeta
{
    BlockMeta meta[];
} block_meta;

layout(set = 0, binding = 2) writeonly buffer SSBOBlockStats
{
    BlockStats stats[];
} block_stats;

layout(set = 0, binding = 3) buffer Payloads
{
    layout(offset = 0) uint counter;
    layout(offset = 8) uint8_t data[];
} payload_data;

#include "dwt_swizzle.h"

layout(push_constant) uniform Registers
{
    ivec2 resolution;
    vec2 inv_resolution;
    int input_layer;
    float quant_resolution;
    int block_offset;
    int block_stride;
} registers;

float max4(vec4 v)
{
    vec2 v2 = max(v.xy, v.zw);
    return max(v2.x, v2.y);
}

int max4(ivec4 v)
{
    ivec2 v2 = max(v.xy, v.zw);
    return max(v2.x, v2.y);
}

void encode_bits(uint payload, uint offset)
{
    uint encoded = payload << (gl_SubgroupInvocationID & 7u);
    encoded |= subgroupShuffleXor(encoded, 1);
    encoded |= subgroupShuffleXor(encoded, 2);
    encoded |= subgroupShuffleXor(encoded, 4);
    if ((gl_SubgroupInvocationID & 7u) == 0u)
        payload_data.data[offset] = uint8_t(encoded);
}

int compute_block4x2_max(int v)
{
    v = max(v, subgroupShuffleXor(v, 1));
    v = max(v, subgroupShuffleXor(v, 2));
    v = max(v, subgroupShuffleXor(v, 4));
    return v;
}

int scan_strided(int v)
{
    for (uint i = 8; i < gl_SubgroupSize; i *= 2)
    {
        int up = subgroupShuffleUp(v, i);
        v += gl_SubgroupInvocationID >= i ? up : 0;
    }

    return v;
}

void compute_quant_scale(float max_wave_texels, out uint quant_code, out float quant_scale)
{
    if (max_wave_texels < 1.0)
    {
        quant_code = ENCODE_QUANT_IDENTITY;
        quant_scale = 1.0;
    }
    else
    {
        int e;
        frexp(max_wave_texels - 0.25, e);
        float target_max = float(1 << e) - 0.25;
        float inv_scale = max_wave_texels / target_max;
        quant_code = encode_quant_scale(inv_scale);
        quant_scale = 1.0 / decode_quant_scale(quant_code);
    }
}

float compute_square_error(float v, int q, out uint num_significant_values)
{
    v = abs(v);
    float iv = float(int(v) >> q);
    num_significant_values = subgroupBallotBitCount(subgroupBallot(iv != 0));
    if (iv != 0.0)
        iv += 0.5;
    iv = ldexp(iv, q);
    float err = v - iv;
    return err * err;
}

struct QuantResult
{
    float square_error;
    int encode_cost_early;
    int block4x2_shifted;
    int encode_cost_late_bits;
    int quality_planes;
};

QuantResult compute_quant_stats(float v, int q, int msb, int block4x2_max, float inv_quant, bool in_range)
{
    block4x2_max >>= q;

    uint num_significants;
    QuantResult result;

    result.square_error = compute_square_error(v, q, num_significants) * inv_quant * inv_quant;
    result.block4x2_shifted = block4x2_max;

    result.encode_cost_early = block4x2_max > 0 ? 1 : 0;
    msb -= q;

    result.quality_planes = 0;

    if (msb >= 3)
    {
        result.quality_planes = msb - 2;
        // Must encode the sign plane if we have quality planes.
        result.encode_cost_early = result.quality_planes + 1;
        result.block4x2_shifted >>= result.quality_planes;
    }

    if (!in_range)
    {
        result.encode_cost_early = 0;
        result.block4x2_shifted = 0;
    }

    result.encode_cost_early += findMSB(result.block4x2_shifted) + 1;
    result.encode_cost_late_bits = subgroupAdd(max(result.encode_cost_early - 1, 0)) + int(num_significants);
    return result;
}

float square(float v)
{
    return v * v;
}

void encode_payload32(float texel0, float texel1, bool in_range0, bool in_range1)
{
    float max_wave_texels = subgroupMax(max(abs(texel0), abs(texel1)));
    float quant_scale;
    uint quant_code;
    compute_quant_scale(max_wave_texels, quant_code, quant_scale);
    texel0 *= quant_scale;
    texel1 *= quant_scale;

    float overall_quant_scale = registers.quant_resolution * quant_scale;
    float inv_quant = 1.0 / overall_quant_scale;

    int quant_texel0 = int(texel0);
    int quant_texel1 = int(texel1);
    int abs_quant_texel0 = abs(quant_texel0);
    int abs_quant_texel1 = abs(quant_texel1);
    int max_absolute_value = subgroupMax(max(abs_quant_texel0, abs_quant_texel1));

    uint block_index = registers.block_offset + gl_WorkGroupID.y * registers.block_stride + gl_WorkGroupID.x;

    // The entire block quantizes to zero.
    if (max_absolute_value == 0)
    {
        if (subgroupElect())
        {
            block_meta.meta[block_index] = BlockMeta(0, 0);
            block_stats.stats[block_index].num_planes = 0;
            block_stats.stats[block_index].errors[0] = QuantStats(float16_t(0.0), uint16_t(0));
        }
        return;
    }

    int msb = findMSB(max_absolute_value);
    int block4x2_0 = compute_block4x2_max(abs_quant_texel0);
    int block4x2_1 = compute_block4x2_max(abs_quant_texel1);

    QuantResult result0 = compute_quant_stats(texel0, 0, msb, block4x2_0, inv_quant, in_range0);
    QuantResult result1 = compute_quant_stats(texel1, 0, msb, block4x2_1, inv_quant, in_range1);
    int scan0 = scan_strided(result0.encode_cost_early);
    int scan1 = scan_strided(result1.encode_cost_early);
    scan1 += subgroupBroadcast(scan0, gl_SubgroupSize - 1);

    uint global_offset = 0;

    // For feedback, and allocation of payload.
    if (gl_SubgroupInvocationID == gl_SubgroupSize - 1)
        global_offset = atomicAdd(payload_data.counter, scan1);
    global_offset = subgroupBroadcast(global_offset, gl_SubgroupSize - 1);

    // First, encode the code word.
    uint code_word = result0.quality_planes << Q_PLANES_OFFSET;
    code_word = bitfieldInsert(code_word, quant_code, QUANT_SCALE_OFFSET, QUANT_SCALE_BITS);
    uint plane_code0 = findMSB(result0.block4x2_shifted) + 1;
    uint plane_code1 = findMSB(result1.block4x2_shifted) + 1;
    uint plane_code = plane_code0 | (plane_code1 << 8);

    code_word |= subgroupBroadcast(plane_code, 0) << 0;
    code_word |= subgroupBroadcast(plane_code, 8) << 2;
    code_word |= subgroupBroadcast(plane_code, 16) << 4;
    code_word |= subgroupBroadcast(plane_code, 24) << 6;

    if (subgroupElect())
    {
        block_meta.meta[block_index] = BlockMeta(code_word, global_offset);
        block_stats.stats[block_index].num_planes = msb + 1;
        block_stats.stats[block_index].errors[0] = QuantStats(
            float16_t(0.0), // We don't care about distortion from 0 quant since we've already made that decision.
            uint16_t(result0.encode_cost_late_bits + result1.encode_cost_late_bits));
    }

    for (int q = 1; q <= msb; q++)
    {
        result0 = compute_quant_stats(texel0, q, msb, block4x2_0, inv_quant, in_range0);
        result1 = compute_quant_stats(texel1, q, msb, block4x2_1, inv_quant, in_range1);
        float square_error = subgroupAdd(result0.square_error + result1.square_error);

        if (subgroupElect())
        {
            block_stats.stats[block_index].errors[q] = QuantStats(
                float16_t(square_error),
                uint16_t(result0.encode_cost_late_bits + result1.encode_cost_late_bits));
        }
    }

    float square_error = subgroupAdd(square(texel0 * inv_quant) + square(texel1 * inv_quant));
    if (subgroupElect())
        block_stats.stats[block_index].errors[msb + 1] = QuantStats(float16_t(square_error), uint16_t(0));

    if (in_range0)
    {
        uint word_offset0 = scan0 - result0.encode_cost_early + global_offset;
        bool need_sign0 = result0.block4x2_shifted != 0 || result0.quality_planes != 0;

        // Don't pack the sign plane until final pass, since we don't know how we quantize yet.
        if (need_sign0)
        {
            encode_bits(int(texel0 < 0.0), word_offset0);
            word_offset0++;
        }

        int plane_iterations0 = result0.quality_planes + int(plane_code0);
        for (int q = plane_iterations0 - 1; q >= 0; q--)
        {
            encode_bits(bitfieldExtract(uint(abs_quant_texel0), q, 1), word_offset0);
            word_offset0++;
        }
    }

    if (in_range1)
    {
        uint word_offset1 = scan1 - result1.encode_cost_early + global_offset;
        bool need_sign1 = result1.block4x2_shifted != 0 || result1.quality_planes != 0;

        if (need_sign1)
        {
            encode_bits(int(texel1 < 0.0), word_offset1);
            word_offset1++;
        }

        int plane_iterations1 = result1.quality_planes + int(plane_code1);
        for (int q = plane_iterations1 - 1; q >= 0; q--)
        {
            encode_bits(bitfieldExtract(uint(abs_quant_texel1), q, 1), word_offset1);
            word_offset1++;
        }
    }
}

void main()
{
    ivec2 base_coord = ivec2(gl_WorkGroupID.xy) * 16;

#if 0
    if (gl_SubgroupSize == 64)
    {
        ivec2 local_coord = unswizzle8x8_2x2_quant(gl_SubgroupInvocationID);

        ivec2 top_left_coord = base_coord + local_coord * 2;
        vec2 gather_uv = vec2(top_left_coord) * registers.inv_resolution;

        vec4 texels = textureGatherOffset(uTexture, vec3(gather_uv, registers.input_layer), ivec2(1), 0).wzxy;
        vec4 scaled_texels = texels * registers.quant_resolution;

        bool in_range = all(lessThan(top_left_coord & ivec2(~7, ~3), registers.resolution));
        encode_payload64(scaled_texels, in_range);
    }
    else
#endif
    if (gl_SubgroupSize == 32)
    {
        ivec2 local_coord = unswizzle4x8(gl_SubgroupInvocationID);

        ivec2 top_left_coord = base_coord + local_coord;

        float texel0 = texelFetch(uTexture, ivec3(top_left_coord, registers.input_layer), 0).x;
        float texel1 = texelFetch(uTexture, ivec3(top_left_coord + ivec2(4, 0), registers.input_layer), 0).x;

        float scaled_texel0 = texel0 * registers.quant_resolution;
        float scaled_texel1 = texel1 * registers.quant_resolution;

        ivec2 snapped_top_left = top_left_coord & ivec2(-4, -2);

        bool in_range0 = all(lessThan(snapped_top_left, registers.resolution));
        bool in_range1 = all(lessThan(snapped_top_left + ivec2(4, 0), registers.resolution));
        encode_payload32(scaled_texel0, scaled_texel1, in_range0, in_range1);
    }
#if 0
    else if (gl_SubgroupSize == 16)
    {
        ivec2 local_coord = unswizzle4x8_2x2_quant(gl_SubgroupInvocationID);

        ivec2 top_left_coord = base_coord + local_coord * 2;
        ivec2 gather_coord = top_left_coord + ivec2(5, 5);
        vec2 gather_uv = vec2(gather_coord) * registers.inv_resolution;

        vec4 texels0 = textureGatherOffset(uTexture, vec3(gather_uv, registers.input_layer), ivec2(-4, -4), 0).wzxy;
        vec4 texels1 = textureGatherOffset(uTexture, vec3(gather_uv, registers.input_layer), ivec2(-4, 4), 0).wzxy;
        vec4 texels2 = textureGatherOffset(uTexture, vec3(gather_uv, registers.input_layer), ivec2(4, -4), 0).wzxy;
        vec4 texels3 = textureGatherOffset(uTexture, vec3(gather_uv, registers.input_layer), ivec2(4, 4), 0).wzxy;

        vec4 scaled_texels0 = texels0 * registers.quant_resolution;
        vec4 scaled_texels1 = texels1 * registers.quant_resolution;
        vec4 scaled_texels2 = texels2 * registers.quant_resolution;
        vec4 scaled_texels3 = texels3 * registers.quant_resolution;

        ivec2 snapped_top_left = top_left_coord & ivec2(~7, ~3);

        bool in_range0 = all(lessThan(snapped_top_left, registers.resolution));
        bool in_range1 = all(lessThan(snapped_top_left + ivec2(0, 8), registers.resolution));
        bool in_range2 = all(lessThan(snapped_top_left + ivec2(8, 0), registers.resolution));
        bool in_range3 = all(lessThan(snapped_top_left + ivec2(8, 8), registers.resolution));

        encode_payload16(
            scaled_texels0, scaled_texels1, scaled_texels2, scaled_texels3,
            in_range0, in_range1, in_range2, in_range3);
    }
#endif
}